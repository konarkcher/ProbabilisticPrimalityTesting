\documentclass[12pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{secdot}

\textheight=24cm
\textwidth=16cm
\oddsidemargin=0pt
\topmargin=-1.5cm
\parindent=24pt
\parskip=0pt
\tolerance=2000\flushbottom

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[]{algorithm2e}
\usepackage[shortlabels]{enumitem}
\theoremstyle{definition}

\title{Сложность вычислений. \\
Вероятностная проверка на простоту без ошибок}
\date{}
\author{Константин Чернис, группа 694}

\newtheorem*{Def*}{Определение}
\newtheorem*{Th*}{Теорема}

\newtheorem{Def}{Определение}
\newtheorem{Th}{Теорема}
\newtheorem{St}{Утверждение}
\numberwithin{Def}{section}
\numberwithin{Th}{section}
\numberwithin{St}{section}

\newenvironment{Proof}                            {\par\noindent{\bf Доказательство.}}        {\hfill$\scriptstyle\blacksquare$}

\newcommand{\Set}[2]{
  \{\, #1 \mid #2 \, \}
}

\begin{document}
\begin{titlepage}
	\centering
	{\scshape\Large Сложность вычислений\par}
	\vspace{1.5cm}
	{\huge\bfseries Вероятностная проверка на простоту без ошибок\par}
	\vspace{2cm}
	{\Large Чернис Константин, группа 694\par}
	\newpage
\end{titlepage}
\tableofcontents
\newpage

В данном проекте доказываются избранные факты вероятностной
проверки чисел на простоту, а также проводятся некоторые 
эксперименты.

\section{Введение в сложностные классы}

Для начала опишем сложностные классы, затрагиваемые данной задачей:

\begin{Def}
	Вероятностной машиной Тьюринга называется детерминированная машина Тьюринга $M$ с
	двумя аргументами $x$ (аргумент вероятностной машины) и $r$ (случайные биты), где
	длина $r$ есть некоторая функция от длины $x$. Результатом работы $M$ на входе $x$
	будет вероятностое распределение, индуцированное данным $x$ и равномерным на всех
	значениях $r$. Временем работы $M$ на данном $x$ будем считать максимальное время работы
	$M(x,r)$ для всех $r$ указанной длины. Так же определяется и использованная память.
\end{Def}

\begin{Def}
	Классом \textbf{RP} называется класс языков $A$, для которых существует полиномиальный
	в худшем случае вероятностный алгоритм $V$, такой что:
	
	\begin{itemize}
		\item если $x\in A$, то $P_r[V(x,r)=1]\geqslant\dfrac 12$;
		\item если $x\notin A$, то $P_r[V(x,r)=1]=0$.
	\end{itemize}
\end{Def}

\begin{Def}
	Классом \textbf{coRP} называется класс языков $A$, для которых существует полиномиальный
	в худшем случае вероятностный алгоритм $V$, такой что:
	
	\begin{itemize}
		\item если $x\in A$, то $P_r[V(x,r)=1]=1$;
		\item если $x\notin A$, то $P_r[V(x,r)=1]\leqslant\dfrac 12$.
	\end{itemize}	
\end{Def}
	
\begin{Def}
	Классом \textbf{ZPP} называется класс языков $A$, для которых существует
	вероятностный алгоритм $A$, такой что
	$$
	x\in A\iff\forall r\; V(x,r)=1,
	$$
	а для каждого $x$ ожидаемое по $r$ время работы полиномиально.
\end{Def}

Обозначение \textbf{ZPP} расшифровывается как "zero-error probabistic
polynomial".

\begin{St}
$\mathbf{ZPP=RP\cap coPR}$.
\end{St}

Таким образом, для вероятностной проверки чисел на простоту достаточно
предоставить алгоритмы проверки чисел на простоту из \textbf{RP} и \textbf{coRP},
после чего запускать их по очереди до тех пор, пока один из алгоритмов
не выдаст ответ, в котором он уверен. Вероятность отсутствия ответа будет
уменьшаться минимум в 4 раза после каждой итерации цикла проверки, так что
за полиномиальное число шагов вероятность станет экспоненциально малой и можно
будет применить детерминированный экспоненциальный алгоритм.

В следующей секции будет описан алгоритм из \textbf{coRP}, а в секции 3~"--- из
\textbf{RP}.

\section{Алгоритм Миллера-Рабина}

Большинство алгоритмов вероятностной проверки на простоту из \textbf{coRP}
опираются на какое-либо свойство простых чисел, то есть проверяют необходимое
условие. Наиболее популярным среди них является алгоритм Миллера-Рабина, который
гарантирует, что для нечётного составного минимум $75\%$ чисел от $1$ до $n-1$
позволяют определить его непростоту.

Говоря в терминах Определения 1.3,
$A$~"--- множество простых чисел, и для
$x\notin A$ $P_r[V(x,r)=1]\leqslant\dfrac 14$, где $r\in\overline{1,n-1}$.
Кроме того, как будет показано ниже, проверяемое условие действительно
является необходимым, то есть для $x\in A$ $P_r[V(x,r)=1]=1$, то есть
алгоритм Миллера-Рабина лежит в \textbf{coNP}.

\subsection{Описание алгоритма}
\newcommand{\Mod}[1]{\ \mathrm{mod}\ #1}

Заданное нечётное целое число $n>1$ можно представить в виде $n-1=2^ek$,
где $e\geqslant 1$ (т.к. $n$ нечётно) и $k$ нечётное. Применяя к
$x^{n-1}-1=x^{2^ek}-1$ формулу разности квадратов, получаем:
\begin{align*}
	x^{2^ek}-1&=\left(x^{2^{e-1}k}\right)^2-1 \\
	&=\left(x^{2^{e-1}k}-1\right)\left(x^{2^{e-1}k}+1\right) \\
	&=\left(x^{2^{e-2}k}-1\right)\left(x^{2^{e-2}k}+1\right)
	\left(x^{2^{e-1}k}+1\right) \\
	&\;\;\vdots \\
	&=\left(x^k-1\right)\left(x^k+1\right)\left(x^{2k}+1\right)
	\left(x^{4k}+1\right)\ldots\left(x^{2^{e-1}k}+1\right)
\end{align*}
Если $n$ простое и $a\in\overline{1,n-1}$, то
по малой теореме Ферма $a^{n-1}-1\equiv 0\Mod{n}$. Используя разложение,
полученное выше, имеем
$$
\left(x^k-1\right)\left(x^k+1\right)\left(x^{2k}+1\right)
	\left(x^{4k}+1\right)\ldots\left(x^{2^{e-1}k}+1\right)\equiv 0\Mod{n}
$$
Таким образом, для простого $n$ один из множителей должен делиться на $n$,
то есть необходимым условием, нарушение которого означает, что число составное,
является
$$
a^k\equiv 1\Mod{n}\text{ или } a^{2^ik}\equiv -1\Mod{n} \text{ для некоторого } 
i\in\overline{0,e-1}.
$$

\begin{Def}
Представим нечётное $n>1$ в виде $n-1=2^ek$, где $e$ нечётно и выберем
$a\in\overline{1,n-1}$. Тогда $a$ называется свидетелем для числа $n$, если
не выполнено необходимое условие, то есть
$$
a^k\not\equiv1\Mod{n}\text{ и } a^{2^ik}\not\equiv-1\Mod{n}\;\forall 
i\in\overline{0,e-1}.
$$
Если же необходимое условие выполнено, то есть
$$
a^k\equiv 1\Mod{n}\text{ или } a^{2^ik}\equiv -1\Mod{n} \text{ для некоторого } 
i\in\overline{0,e-1},
$$
то $a$ не является свидетелем для $n$.
\end{Def}

Отметим, что уже сейчас можно построить вероятностный алгоритм проверки на
простоту со сколь угодно малой вероятностью ошибки:
\\\\
\begin{algorithm*}[H]
 \KwData{проверяемое число $n$, количество итераций $t$}
 \KwResult{является ли число $n$ простым}
  \For{$i \in\overline{1,t}$}{
  выбрать случайное $a$ из $\overline{1,n-1}$\;
  \If{$a$ является свидетелем для $n$}{
   \Return "n составное"\;
   }
 }
 \Return "$n$ простое с вероятностью минимум $1-1/4^t$"\;
\end{algorithm*}
 
\subsection{Доказательство оценки на число свидетелей}

Для начала покажем, что оценка $75\%$ неулучшаема:
 
\begin{St}
	Доля свидетелей для $n=9$ составляет $3/4$.	
\end{St}

\begin{Proof}
	$n-1=8=2^3$, так что $e=3$ и $k=1$, и для проверки необходимого условия
	надо перебрать $(a,a^2,a^3)$. Из приведённой ниже таблицы видно, что
	свидетелями среди $\overline{1,8}$ являются $2, 3, 4, 5, 6, 7$, что
	составляет $6/8=1/4$, что и требовалось.
	
	\begin{center}
	\begin{tabular}{ c|c|c|c|c|c|c|c|c}
    $a\Mod 9$   & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ \\ \hline
    $a^2\Mod 9$ & $1$ & $4$ & $0$ & $7$ & $7$ & $0$ & $4$ & $1$ \\
    $a^3\Mod 9$ & $1$ & $7$ & $0$ & $4$ & $4$ & $0$ & $7$ & $1$
  \end{tabular}
\end{center}
\end{Proof}

Существует также доказательство неулучшаемости оценки при $n\to\infty$,
оно приведено в \ref{Monier}.

\begin{Th}
 	Пусть $n>1$ нечётное составное.
 
 	Доля целых чисел среди $\overline{1,n-1}$, являющихся свидетелями числа $n$,
 	превышает $75\%$, за исключением $n=9$, для которого доля составляет $75\%$.
 	
 	Другими словами, доля целых чисел среди $\overline{1,n-1}$, не являющихся
 	свидетелями числа $n$, меньше $25\%$, за исключением $n=9$, для которого доля 
 	составляет $25\%$.
\end{Th}

Докажем более слабое утверждение:

\begin{Th}
	Если $n>1$ нечётное и составное, то доля свидетелей числа $n$ превышает
	$50\%$. Другими словами, больше $50\%$ из $a\in\overline{1,n-1}$
	удовлетворяют $a^k\not\equiv 1\Mod{n}$ и
	$a^{2^ik}\not\equiv-1\Mod{n}\;\forall i\in\overline{0,e-1}$.
\end{Th}

\begin{Proof}
	Докажем, что доля не свидетелей для $n$ меньше $50\%$, показав, что они
	образуют собственную подгруппу группы обратимых чисел$\Mod{}n$. В силу того,
	что порядок собственной подгруппы составляет максимум половину от порядка
	группы, множество свидетелей числа $n$ содержит минимум половину обратимых
	чисел$\Mod{n}$ и все необратимые числа$\Mod{n}$ среди $\overline{1,n-1}$
	(множество необратимых непусто в силу того, что $n$ составное).
	Таким образом, доля свидетелей для числа $n$ первышает $50\%$.
	
	\textbf{Случай 1:} $n$ является степенью простого числа,
	то есть $n=p^\alpha$, где $p$ — нечётное простое и $\alpha\geqslant 2$.
	
	\begin{St}
		Если $n=p^\alpha$ для простого $p$ и $\alpha\geqslant 1$, то
		не свидетели для $n$ являются корнями уравнения
		$a^{p-1}\equiv 1\Mod{p^\alpha}$, которые образуют группу по
		умножению$\Mod{n}$.
	\end{St}
	
	\begin{Proof}
		Обоснование приведено в \ref{Conrad}.
	\end{Proof}
	\\\\
	Согласно Утверждению 2.2 свидетели непростоты образуют группу по умножению
	$\Mod{n}$. Порядок числа $a$, являющегося решением уравнения
	$a^{p-1}\equiv1\Mod{n}$, делит $p-1$, так что он не делится на $p$. В то же
	время существуют обратимые$\Mod{n}$ числа, порядок которых делится на $p$:
	примером такого числа является $1+p$, чей порядок$\Mod{p^\alpha}$ составляет
	$p^{\alpha-1}$ (этот факт можно показать индукцией по $r$: база~"---
	$1+kp\equiv 1\Mod{p}$, переход~"--- $(1+kp^r)^p\equiv 1\Mod{p^{r+1}}$).
	Таким образом, не свидетели$\Mod{n}$ образуют собственную подгруппу в группе
	обратимых чисел$\Mod{n}$, что заканчивает доказательство этого случая.
	\\\\
	\textbf{Случай 2:} $n$ не является степенью простого. Пусть
	$i_0\in\overline{0,e-1}$~"--- максимальное число, такое что
	$\exists\,a_0\in\mathbb{Z}$ такой что $a^{2^{i_0}}\equiv-1\Mod{n}$.
	(В силу того, что $(-1)^{2^0}=-1$, требуемый $i_0$ существует, причём
	$a_0$ взаимно прост с $n$).
		
	Множество
	$$
	G_n=\Set{a\in\overline{1,n-1}}{a^{2^{i_0}k}\equiv\pm1\Mod{n}}
	$$ 
	является группой по умножению$\Mod{n}$ и содержит все $a$, удовлетворяющие
	одному из двух условий:
	\begin{enumerate}[(1)]
		\item $a^k\equiv 1\Mod{n}$,
		\item $a^{2^ik}\equiv 1\Mod{n}$ для одного из $i\in\overline{0,e-1}$.
	\end{enumerate}
	
	Если $a^k\equiv 1\Mod{n}$, то $a^{2^{i_0}k}\equiv 1\Mod{n}$. Если же
	$a^{2^ik}\equiv 1\Mod{n}$ для некоторого $i\in\overline{0,e-1}$, то
	$\left(2^k\right)^{2^i}\equiv-1\Mod{n}$, причём $i\leqslant i_0$ в силу
	максимальности $i_0$. Таким образом, $a^{2^{i_0}}\equiv -1\Mod{n}$, если
	$i=i_0$, и $a^{2^{i_0}}=1\Mod{n}$, если $i<i_0$. Отсюда все
	$a\in\overline{1,n-1}$, удовлетворяющие (1) или (2), лежат в $G_n$.
	
	Покажем, что $G_n$ является собственной подгруппой обратимых чисел$\Mod{n}$,
	для чего найдём обратимое число, не лежащее в $G_n$. Пусть $p$~"--- простой
	делитель $n$, тогда представим $n$ в виде $n=p^\alpha n'$, где
	$\alpha\geqslant 1$ и $p\nmid n'$. $p^\alpha$ и $n'$ нечётные и не равны $1$
	(в силу того, что $n$ не является степенью простого) $\implies$
	$p^\alpha,n'\geqslant 3$.
	
	Согласно китайской теореме об остатках, $\exists\,a\in\overline{1,n-1}$,
	удовлетворяющий следующим двум уравнениям:
	$$
	a\equiv a_0\Mod{p^\alpha}, \quad a\equiv 1\Mod{n'}. 
	$$
	Выше показали, что $(a_0,n)=1\implies (a,n)=1$ (т.к. $(a,n')=1$), то есть
	$a$ является обратимым$\Mod{n}$. Тогда для доказательства того, что подгруппа
	$G_n$ не является собственной, остаётся показать, что $a\notin G_n$.
	
	$$
	a^{2^{i_0}k}\equiv a^{2^{i_0}k}_0 \equiv (-1)^k\equiv -1\Mod{p^\alpha}
	\implies a^{2^{i_0}k}\not\equiv 1\Mod{n}
	$$
	в силу того, что $-1\not\equiv 1\Mod{p^\alpha}$ (т.к. $p^\alpha\geqslant 3$).
	Кроме того,
	$$
	a^{2^{i_0}k}\equiv 1\Mod{n'}\implies a^{2^{i_0}k}\not\equiv -1\Mod{n}
	$$
	в силу того, что $-1\not\equiv 1\Mod{n'}$ (т.к. $n'\geqslant 3$). Таким
	образом, $a\notin G_n$, что завершает доказательство данного случая, а с ним
	и всей теоремы.
\end{Proof}
\\\\
Теорема 2.1 доказазывается аналогичным образом, оценка $1/4$ на число
не свидетелей достигается за счёт двукратного применения приёма с собственной
подгруппой. Полное доказательство описано в \ref{Conrad}.

\section{Алгоритм Эдельмана-Хуана}

\section{Алгоритм ECPP}

\section{Список литературы}

\begin{enumerate}[{[}1{]}]
	\item Д.В. Мусатов. “Сложность вычислений.”
	\item \label{Conrad} Conrad, Keith. (2017). “The Miller – Rabin Test.”
	\item \label{Monier} Monier, Louis. (1980). "Evaluation and comparison of two efficient
	probabilistic primality testing algorithms".
	Theoretical Computer Science. 12. 97–108.
\end{enumerate}

\end{document}